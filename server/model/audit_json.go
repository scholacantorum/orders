package model

// Code generated by easyjson and then hand-edited.

import (
	"encoding/json"
	"time"

	"github.com/mailru/easyjson"
	"github.com/mailru/easyjson/jlexer"
	"github.com/mailru/easyjson/jwriter"
)

// suppress unused package warning
var (
	_ *json.RawMessage
	_ *jlexer.Lexer
	_ *jwriter.Writer
	_ easyjson.Marshaler
)

// encodeTimestamp does the same thing as time.Time.MarshalJSON, except that it
// uses local time without including a time zone designator, and it doesn't
// include fractional seconds.
func encodeTimestamp(out *jwriter.Writer, in time.Time) {
	b := make([]byte, 0, len(time.RFC3339))
	b = in.In(time.Local).AppendFormat(b, time.RFC3339)
	out.RawText(b, nil)
}

func encodeAuditRecord(out *jwriter.Writer, in *AuditRecord) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"timestamp\":"
		first = false
		out.RawString(prefix[1:])
		encodeTimestamp(out, in.Timestamp)
	}
	if in.Username != "" {
		const prefix string = ",\"username\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Username))
	}
	if in.Request != "" {
		const prefix string = ",\"request\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Request))
	}
	if in.Event != nil {
		const prefix string = ",\"event\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		// TODO
	}
	if in.Order != nil {
		const prefix string = ",\"order\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		encodeOrder(out, in.Order, true)
	}
	if in.Product != nil {
		const prefix string = ",\"product\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		// TODO
	}
	if in.Session != nil {
		const prefix string = ",\"session\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		// TODO
	}
	out.RawString("}\n")
}

// ToJSON renders an audit record in JSON form.
func (ar *AuditRecord) ToJSON() []byte {
	w := jwriter.Writer{}
	encodeAuditRecord(&w, ar)
	return w.Buffer.BuildBytes()
}
